#!/usr/bin/perl
# For a list of given QIIME OTU ids, pull out the sequences from the combined_seqs.fna file
# Provides a wrapper around filter_fasta.py script from QIIME

#This program is free software: you can redistribute it and/or modify
#it under the terms of the GNU General Public License as published by
#the Free Software Foundation, either version 3 of the License, or
#(at your option) any later version.
 
#This program is distributed in the hope that it will be useful,
#but WITHOUT ANY WARRANTY; without even the implied warranty of
#MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#GNU General Public License for more details.
 
#You should have received a copy of the GNU General Public License
#along with this program.  If not, see <http://www.gnu.org/licenses/>.

$USAGE = q/USAGE:
perl extract_sequences_for_OTU_ids.pl          -l, --lst <filename>    file containing a list of OTU IDs for which sequences have to be extracted
					       
					       -m, --mapfile <filename> 
								       Map file generated by the QIIME pick_open_reference_otus.py script
								       This file maps the read sequence IDs to each reference OTU ID
					       
					       --seqfile <filename>
                                               
                                               -o, --out <\/path\/to\/output\/directory> 
                                                                       complete path to the diretory where you want to store the cleaned up InterPro Scan result files: 
                                                                       
                                     
                                     OPTIONAL: 
                                               Extract only for specific samples
                                               
                                               --sample <comma,separated,string,of,sample,names> 
                                                                      Comma separated string of sample IDs for extracting sample-specific sequences
                                                                      e.g --sample S1,S2 
                                                                      where S1,S2 are QIIME sample IDs
                                               --cleanup <Y\/N>       Boolean for removing temporary ID file generated during the run                       
                                                                      
                                                                      
                                                                                                                     
/;

use Getopt::Long;
use Data::Dumper;
# use Bio::SeqIO;

GetOptions (
'l|lst=s' => \$otulist,
'o|out=s' => \$outpath,
'm|mapfile=s' => \$otumap,
'seqfile=s'   => \$seqfile,
'sample=s' => \$sampstr,
'cleanup=s' => \$cleanup
) or die $USAGE;

die $USAGE if !$otulist or !$outpath or !$otumap or !$seqfile;

open(F,$otulist);
chomp (@otus=<F>);
@otuhash{@otus}=1;

# print Dumper (\%otuhash);

open (M,$otumap);

($inpath,$in_fname) = $otulist =~ m|^(.*[/])([^/]+?)$|;

print "Output tag to use ... $outpath/$in_fname <---- \n";
open (TMPMAPOUT,">$outpath/$in_fname.tmp.map");

while ($line=<M>)
{
chomp $line;
@tmp=split(/\t/,$line);
$otuid=$tmp[0];
# print "$tmp[0]\n";
# $hashmap{$tmp[0]}=$line;
  if (exists $otuhash{$otuid})
  {
  print TMPMAPOUT "$line\n";
  
    if ($sampstr)
    {
    @samps=split(/,/,$sampstr);
    
      foreach $sampid (@samps)
      {
      @sampseqids=();
      
	foreach $seqid (@tmp)
	{
	  if ($seqid =~ /$sampid\_/)
	  {
	  push (@sampseqids,$seqid);  
	  }
	}
      
      $sampotuhash{$otuid}{$sampid}=[@sampseqids]
      }
    }
  }
}
close TMPMAPOUT;

print "Extracting all sequences for all OTUs\n\n";
print("filter_fasta.py -f $seqfile -o $outpath/$in_fname.extracted.fasta -m $outpath/$in_fname.tmp.map\n");
system("filter_fasta.py -f $seqfile -o $outpath/$in_fname.extracted.fasta -m $outpath/$in_fname.tmp.map");


# print Dumper (\%sampotuhash);

if ($sampstr)
{
print "Sample string given; Extracting sample-wise\n\n";

foreach (sort keys %sampotuhash)
  {
  
    foreach $s (split(/,/,$sampstr))
    {
    print "$s .....\n";
    open(OUT,">$outpath/$_.$s.seq-ids.tmp");
    $ref=$sampotuhash{$_}{$s};
    @ids=@$ref;
    $idstr=join ("-",@ids);
    $idstr=~s/\-/\n/g;
    print OUT $idstr;
    #@hashsampids{@ids}=1;
    

    print ("filter_fasta.py -f $outpath/$in_fname.extracted.fasta -o $outpath/$_.$s.seq-out.fasta -s $outpath/$_.$s.seq-ids.tmp\n");
    system("filter_fasta.py -f $outpath/$in_fname.extracted.fasta -o $outpath/$_.$s.seq-out.fasta -s $outpath/$_.$s.seq-ids.tmp");
    }
  } 
}



if ($cleanup eq "Y")
{
print "Cleaning up temp files\n\n";
system ("rm $outpath/*.tmp");
system ("rm $outpath/*tmp.map");
}

